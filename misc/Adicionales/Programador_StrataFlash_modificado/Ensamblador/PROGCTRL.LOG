KCPSM3 Assembler log file for program 'progctrl.psm'.
Generated by KCPSM3 version 1.20
Ken Chapman (Xilinx Ltd) 2004.

 Addr Code

 000                                 ;KCPSM3 Program - UART programming of StrataFLASH memory on the Spartan-3E Starter Kit.
 000                                 ;MODIFICADO POR JORGE MÁRQUEZ EN LA LÍNEA 578
 000                                 ;Ken Chapman - Xilinx Ltd
 000                                 ;
 000                                 ;Version v1.00 - 28th March 2006
 000                                 ;
 000                                 ;This program uses a 115200 baud UART connection with XON/XOFF flow control
 000                                 ;to allow a standard MCS file for the configuration of a Spartan-3E device to
 000                                 ;be programmed into the Intel StrataFLASH device on the board.
 000                                 ;
 000                                 ;
 000                                 ;
 000                                 ;
 000                                 ;**************************************************************************************
 000                                 ; Port definitions
 000                                 ;**************************************************************************************
 000                                 ;
 000                                 ;
 000                                 CONSTANT status_port, 00                       ;UART and filter status input
 000                                 CONSTANT tx_data_present, 01                   ;  Transmitter  data present - bit0
 000                                 CONSTANT tx_half_full, 02                      ;    FIFO          half full - bit1
 000                                 CONSTANT tx_full, 04                           ;                       full - bit2
 000                                 CONSTANT rx_data_present, 08                   ;               data present - bit3
 000                                 CONSTANT rx_half_full, 10                      ;  Receiver        half full - bit4
 000                                 CONSTANT rx_full, 20                           ;    FIFO               full - bit5
 000                                 CONSTANT spare1, 40                            ;                  spare '0' - bit6
 000                                 CONSTANT SF_STS, 80                            ;            StrataFLASH STS - bit7
 000                                 ;
 000                                 CONSTANT UART_read_port, 01                    ;UART Rx data input
 000                                 ;
 000                                 CONSTANT UART_write_port, 04                   ;UART Tx data output
 000                                 ;
 000                                 ;
 000                                 CONSTANT SF_data_in_port, 02                   ;Read data from StrataFLASH device
 000                                 ;
 000                                 CONSTANT SF_data_out_port, 10                  ;Data to write into StrataFLASH device
 000                                 ;
 000                                 CONSTANT SF_addr_hi_port, 80                   ;StrataFLASH address[23:16]
 000                                 CONSTANT SF_addr_mi_port, 40                   ;StrataFLASH address[15:8]
 000                                 CONSTANT SF_addr_lo_port, 20                   ;StrataFLASH address[7:0]
 000                                 ;
 000                                 CONSTANT SF_control_port, 08                   ;StrataFLASH control
 000                                 CONSTANT SF_read, 01                           ;         active High read - bit0
 000                                 CONSTANT SF_ce, 02                             ; active Low device enable - bit1
 000                                 CONSTANT SF_we, 04                             ;         active Low write - bit2
 000                                 ;
 000                                 ;
 000                                 ;
 000                                 ;**************************************************************************************
 000                                 ; Special Register usage
 000                                 ;**************************************************************************************
 000                                 ;
 000                                 NAMEREG sF, UART_data                          ;used to pass data to and from the UART
 000                                 ;
 000                                 ;
 000                                 ;**************************************************************************************
 000                                 ; Useful data constants
 000                                 ;**************************************************************************************
 000                                 ;
 000                                 ;Constant to define a software delay of 1us. This must be adjusted to reflect the
 000                                 ;clock applied to KCPSM3. Every instruction executes in 2 clock cycles making the
 000                                 ;calculation highly predictable. The '6' in the following equation even allows for
 000                                 ;'CALL delay_1us' instruction in the initiating code.
 000                                 ;
 000                                 ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 000                                 ;
 000                                 ;Example: For a 50MHz clock the constant value is (10-6)/4 = 11  (0B Hex).
 000                                 ;For clock rates below 10MHz the value of 1 must be used and the operation will
 000                                 ;become lower than intended.
 000                                 ;
 000                                 CONSTANT delay_1us_constant, 0B
 000                                 ;
 000                                 ;
 000                                 ;
 000                                 ;ASCII table
 000                                 ;
 000                                 CONSTANT character_a, 61
 000                                 CONSTANT character_b, 62
 000                                 CONSTANT character_c, 63
 000                                 CONSTANT character_d, 64
 000                                 CONSTANT character_e, 65
 000                                 CONSTANT character_f, 66
 000                                 CONSTANT character_g, 67
 000                                 CONSTANT character_h, 68
 000                                 CONSTANT character_i, 69
 000                                 CONSTANT character_j, 6A
 000                                 CONSTANT character_k, 6B
 000                                 CONSTANT character_l, 6C
 000                                 CONSTANT character_m, 6D
 000                                 CONSTANT character_n, 6E
 000                                 CONSTANT character_o, 6F
 000                                 CONSTANT character_p, 70
 000                                 CONSTANT character_q, 71
 000                                 CONSTANT character_r, 72
 000                                 CONSTANT character_s, 73
 000                                 CONSTANT character_t, 74
 000                                 CONSTANT character_u, 75
 000                                 CONSTANT character_v, 76
 000                                 CONSTANT character_w, 77
 000                                 CONSTANT character_x, 78
 000                                 CONSTANT character_y, 79
 000                                 CONSTANT character_z, 7A
 000                                 CONSTANT character_A, 41
 000                                 CONSTANT character_B, 42
 000                                 CONSTANT character_C, 43
 000                                 CONSTANT character_D, 44
 000                                 CONSTANT character_E, 45
 000                                 CONSTANT character_F, 46
 000                                 CONSTANT character_G, 47
 000                                 CONSTANT character_H, 48
 000                                 CONSTANT character_I, 49
 000                                 CONSTANT character_J, 4A
 000                                 CONSTANT character_K, 4B
 000                                 CONSTANT character_L, 4C
 000                                 CONSTANT character_M, 4D
 000                                 CONSTANT character_N, 4E
 000                                 CONSTANT character_O, 4F
 000                                 CONSTANT character_P, 50
 000                                 CONSTANT character_Q, 51
 000                                 CONSTANT character_R, 52
 000                                 CONSTANT character_S, 53
 000                                 CONSTANT character_T, 54
 000                                 CONSTANT character_U, 55
 000                                 CONSTANT character_V, 56
 000                                 CONSTANT character_W, 57
 000                                 CONSTANT character_X, 58
 000                                 CONSTANT character_Y, 59
 000                                 CONSTANT character_Z, 5A
 000                                 CONSTANT character_0, 30
 000                                 CONSTANT character_1, 31
 000                                 CONSTANT character_2, 32
 000                                 CONSTANT character_3, 33
 000                                 CONSTANT character_4, 34
 000                                 CONSTANT character_5, 35
 000                                 CONSTANT character_6, 36
 000                                 CONSTANT character_7, 37
 000                                 CONSTANT character_8, 38
 000                                 CONSTANT character_9, 39
 000                                 CONSTANT character_colon, 3A
 000                                 CONSTANT character_fullstop, 2E
 000                                 CONSTANT character_semi_colon, 3B
 000                                 CONSTANT character_minus, 2D
 000                                 CONSTANT character_plus, 2B
 000                                 CONSTANT character_comma, 2C
 000                                 CONSTANT character_less_than, 3C               ;'<'
 000                                 CONSTANT character_greater_than, 3E            ;'>'
 000                                 CONSTANT character_open, 28                    ;'('
 000                                 CONSTANT character_close, 29                   ;')'
 000                                 CONSTANT character_divide, 2F                  ;'/'
 000                                 CONSTANT character_equals, 3D
 000                                 CONSTANT character_space, 20
 000                                 CONSTANT character_CR, 0D                      ;carriage return
 000                                 CONSTANT character_LF, 0A                      ;line feed
 000                                 CONSTANT character_question, 3F                ;'?'
 000                                 CONSTANT character_dollar, 24
 000                                 CONSTANT character_exclaim, 21                 ;'!'
 000                                 CONSTANT character_BS, 08                      ;Back Space command character
 000                                 CONSTANT character_XON, 11                     ;Flow control ON
 000                                 CONSTANT character_XOFF, 13                    ;Flow control OFF
 000                                 ;
 000                                 ;
 000                                 ;**************************************************************************************
 000                                 ; Scratch Pad Memory Locations
 000                                 ;**************************************************************************************
 000                                 ;
 000                                 CONSTANT ISR_preserve_s0, 00                   ;preserve register during ISR
 000                                 ;
 000                                 ;
 000                                 ;
 000                                 ;Store up to one line of an MCS file as bytes
 000                                 ;A typical data line consists of:-
 000                                 ;:     Start character which is not stored
 000                                 ;10    Number of data bytes included (16 in this case)
 000                                 ;aaaa  Lower 16-bits of the storage address
 000                                 ;00    Record type (data in this case)
 000                                 ;dddd...   Data bytes (typically 16 which is the maximum)
 000                                 ;cc    Checksum
 000                                 ;CR/LF Line will end in carriage return and/or line feed which is not stored.
 000                                 ;
 000                                 ;So a total of 21 bytes could be stored before processing.
 000                                 ;This is located at the end of scratch pad memory.
 000                                 ;
 000                                 CONSTANT line_start, 2B                        ;21 bytes until end of memory
 000                                 CONSTANT data_start, 2F                        ;Start of data field if present
 000                                 ;
 000                                 ;
 000                                 ;**************************************************************************************
 000                                 ; Initialise the system and welcome message
 000                                 ;**************************************************************************************
 000                                 ;
 000  30029              cold_start: CALL SF_init[029]                              ;initialise StrataFLASH controls
 001  3013D                          CALL delay_1s[13D]                             ;delay because UART is fast and JTAG startup sequence can be slow
 002  3C001                          ENABLE INTERRUPT                               ;Interrupt is used for XON/XOFF flow control
 003  301B6           welcome_start: CALL send_CR[1B6]
 004  301BC                          CALL send_welcome[1BC]                         ;start up message and version number
 005                                 ;
 005                                 ;
 005                                 ;**************************************************************************************
 005                                 ; Main menu and command selection
 005                                 ;**************************************************************************************
 005                                 ;
 005                                 ;
 005  30256              warm_start: CALL send_Menu[256]                            ;Menu and command selection
 006  301B6                          CALL send_CR[1B6]
 007                                 ;
 007  301B6                  prompt: CALL send_CR[1B6]
 008  301B6                          CALL send_CR[1B6]
 009  00F3E                          LOAD UART_data[sF], character_greater_than[3E] ;prompt for input
 00A  30154                          CALL send_to_UART[154]
 00B  30024                          CALL read_upper_case[024]
 00C  14045                          COMPARE s0, character_E[45]                    ;test for commands and execute as required
 00D  3502C                          JUMP Z, erase_command[02C]
 00E  14042                          COMPARE s0, character_B[42]
 00F  3502E                          JUMP Z, block_erase_command[02E]
 010  14050                          COMPARE s0, character_P[50]
 011  35049                          JUMP Z, program_command[049]
 012  14057                          COMPARE s0, character_W[57]
 013  3508E                          JUMP Z, write_command[08E]
 014  14052                          COMPARE s0, character_R[52]
 015  350A5                          JUMP Z, read_command[0A5]
 016  14041                          COMPARE s0, character_A[41]                    ;Comando mio
 017  350C4                          JUMP Z, arch_command[0C4]                      ;Comando mio
 018  14049                          COMPARE s0, character_I[49]
 019  350E5                          JUMP Z, SF_information[0E5]
 01A  14048                          COMPARE s0, character_H[48]
 01B  35003                          JUMP Z, welcome_start[003]
 01C  14053                          COMPARE s0, character_S[53]
 01D  350F8                          JUMP Z, SF_status[0F8]
 01E  301B6                          CALL send_CR[1B6]                              ;no valid command input
 01F  00F3F                          LOAD UART_data[sF], character_question[3F]     ;display ???
 020  30154                          CALL send_to_UART[154]
 021  30154                          CALL send_to_UART[154]
 022  30154                          CALL send_to_UART[154]
 023  34007                          JUMP prompt[007]                               ;Try again!
 024                                 ;
 024                                 ;
 024  30142         read_upper_case: CALL read_from_UART[142]                       ;read command character from UART
 025  30154                          CALL send_to_UART[154]                         ;echo character
 026  010F0                          LOAD s0, UART_data[sF]                         ;convert to upper case
 027  30161                          CALL upper_case[161]
 028  2A000                          RETURN
 029                                 ;
 029                                 ;
 029                                 ;**************************************************************************************
 029                                 ; Initialise the StrataFlash Memory control signals.
 029                                 ;**************************************************************************************
 029                                 ;
 029                                 ; SF_read = 0   - Output enable off
 029                                 ; SF_ce = 1     - Deselect StrataFLASH memory
 029                                 ; SF_we = 1     - Write enable off
 029                                 ;
 029                                 ; Register used s0
 029                                 ;
 029  00006                 SF_init: LOAD s0, 06
 02A  2C008                          OUTPUT s0, SF_control_port[08]
 02B  2A000                          RETURN
 02C                                 ;
 02C                                 ;
 02C                                 ;**************************************************************************************
 02C                                 ; Erase Command - Perform bulk erase of the StrataFLASH memory
 02C                                 ;**************************************************************************************
 02C                                 ;
 02C                                 ; This routine executes the block erase command 128 times with a different base
 02C                                 ; address in each case.
 02C                                 ;
 02C                                 ; Note that this could take as long as 8 minutes 30 seconds
 02C                                 ; and even typical times will be approximately 2 minutes.
 02C                                 ;
 02C                                 ; Registers used s1,s7,s8,s9
 02C                                 ;
 02C  009FE           erase_command: LOAD s9, FE                                    ;define base address of block 127 = FE0000
 02D  3402F                          JUMP blocks_erase[02F]
 02E                                 ;
 02E                                 ;
 02E                                 ;**************************************************************************************
 02E                                 ; Block Erase Command - Performs erase of lowest 3 blocks of StrataFLASH memory which
 02E                                 ; covers the address range 000000 to 05FFFF in which the configuration for an XC3S500E
 02E                                 ; would be able to fit (000000 to 045470).
 02E                                 ;**************************************************************************************
 02E                                 ;
 02E                                 ; This routine executes the block erase command 3 times with a different base
 02E                                 ; address in each case.
 02E                                 ;
 02E                                 ; Each block is 128K bytes and therefore has an address range of 000000 to 01FFFF.
 02E                                 ; So each block is separated by 020000 hex.
 02E                                 ;
 02E                                 ; Registers used s0,s1,s7,s8,s9
 02E                                 ;
 02E  00904     block_erase_command: LOAD s9, 04                                    ;define base address of block 3 = 040000
 02F  301B6            blocks_erase: CALL send_CR[1B6]
 030  302F7                          CALL send_Confirm[2F7]                         ;confirm command with a 'Y' which must be upper case
 031  30142                          CALL read_from_UART[142]                       ;read command character from UART
 032  30154                          CALL send_to_UART[154]                         ;echo input
 033  14F59                          COMPARE UART_data[sF], character_Y[59]
 034  35441                          JUMP NZ, abort_erase[041]
 035  301B6                          CALL send_CR[1B6]
 036  3022C                          CALL send_Erase_in_progress[22C]
 037  301B6                          CALL send_CR[1B6]
 038  00800                          LOAD s8, 00                                    ;define lower address of each block = xx0000
 039  00700                          LOAD s7, 00
 03A  00F2E       blocks_erase_loop: LOAD UART_data[sF], character_fullstop[2E]     ;progress dots
 03B  30154                          CALL send_to_UART[154]
 03C  30043                          CALL SF_erase_block[043]                       ;erase block
 03D  1C902                          SUB s9, 02                                     ;decrement base address by 1 block
 03E  35C3A                          JUMP NC, blocks_erase_loop[03A]                ;repeat until block 0 is erased
 03F  3024F                          CALL send_OK[24F]
 040  34007                          JUMP prompt[007]
 041                                 ;
 041  30314             abort_erase: CALL send_Abort[314]
 042  34007                          JUMP prompt[007]
 043                                 ;
 043                                 ;
 043                                 ;**************************************************************************************
 043                                 ; Erase a single 128K Byte block of the StrataFlash Memory
 043                                 ;**************************************************************************************
 043                                 ;
 043                                 ; The 24-bit address of the block should be supplied in register set [s9,s8,s7].
 043                                 ;
 043                                 ; To erase a block the address must be set and then the block erase command (20 hex)
 043                                 ; written to the memory followed by the write confirm command (D0 hex).
 043                                 ;
 043                                 ; The act of erasing a block may take up to 1 second to complete. This routine
 043                                 ; waits for the memory to be ready before restoring the normal read array mode and
 043                                 ; returning.
 043                                 ;
 043                                 ; Registers used s1,s7,s8,s9
 043                                 ;
 043  00120          SF_erase_block: LOAD s1, 20                                    ;block erase command
 044  3010D                          CALL SF_byte_write[10D]
 045  001D0                          LOAD s1, D0                                    ;write confirm command
 046  3010D                          CALL SF_byte_write[10D]
 047  3011A                          CALL wait_SF_ready[11A]                        ;wait for erase to complete
 048  2A000                          RETURN
 049                                 ;
 049                                 ;
 049                                 ;**************************************************************************************
 049                                 ; Program Command - Program StrataFLASH memory with data defined in an MCS file
 049                                 ;**************************************************************************************
 049                                 ;
 049  301B6         program_command: CALL send_CR[1B6]
 04A  30205                          CALL send_Waiting_MCS_file[205]
 04B  3004E                          CALL program_MCS[04E]
 04C  3024F                          CALL send_OK[24F]
 04D  34007                          JUMP prompt[007]
 04E                                 ;
 04E                                 ;**************************************************************************************
 04E                                 ; Program StrataFLASH memory with data defined in an MCS file
 04E                                 ;**************************************************************************************
 04E                                 ;
 04E                                 ;Reads the MCS file from the UART and programs the Strata FLASH device at the locations.
 04E                                 ;specified by the file contents.
 04E                                 ;
 04E                                 ;This routine will continue until an end of file record is detected.
 04E                                 ;For each line of MCS received, the current address will be output so that
 04E                                 ;progress can be monitored.
 04E                                 ;
 04E                                 ;
 04E  30059             program_MCS: CALL read_MCS_line[059]                        ;read line from UART
 04F  30069                          CALL MCS_address[069]                          ;find start address and record type
 050  14B01                          COMPARE sB, 01                                 ;test for end record
 051  2B000                          RETURN Z                                       ;end of programming
 052  14B04                          COMPARE sB, 04                                 ;test for extended address record
 053  3504E                          JUMP Z, program_MCS[04E]                       ;no data with this record and upper address now correct
 054                                 ;
 054                                 ;Assume data record type 00 which is data so need to program specified number
 054                                 ;of bytes into memory at correct address.
 054                                 ;
 054  30190          write_spm_data: CALL send_hex_3bytes[190]                      ;send address to indicate progress
 055  301B6                          CALL send_CR[1B6]
 056  06A2B                          FETCH sA, line_start[2B]                       ;read number of data bytes to program
 057  30079                          CALL SF_buffer_write[079]                      ;write bytes to memory
 058  3404E                          JUMP program_MCS[04E]
 059                                 ;
 059                                 ;
 059                                 ;**************************************************************************************
 059                                 ;Read one line of an MCS file into scratch pad memory
 059                                 ;**************************************************************************************
 059                                 ;
 059                                 ;Reads one line of MCS file format into scratch pad memory starting at location 'line_start'.
 059                                 ;
 059                                 ;The routine detects the line start character ':' ignoring any preceding characters. This
 059                                 ;will remove any additional CR or LF characters.
 059                                 ;
 059                                 ;It then reads each subsequent pair of ASCII characters, converts them to true hex in the
 059                                 ;range 00 to FF and stores them in scratch pad memory.
 059                                 ;
 059                                 ;The end of the line is determined by either a CR or LF character.
 059                                 ;
 059                                 ;The value last returned in register 'sE' will be the pointer to the location in
 059                                 ;scratch pad memory following the last byte for the line read.
 059                                 ;
 059  00E2B           read_MCS_line: LOAD sE, line_start[2B]                        ;initialise SPM memory pointer
 05A  30142     wait_MCS_line_Start: CALL read_from_UART[142]                       ;read character
 05B  14F3A                          COMPARE UART_data[sF], character_colon[3A]     ;test for start character
 05C  3545A                          JUMP NZ, wait_MCS_line_Start[05A]
 05D  30142           read_MCS_byte: CALL read_from_UART[142]                       ;read character
 05E  14F0D                          COMPARE UART_data[sF], character_CR[0D]        ;test for end of line
 05F  2B000                          RETURN Z
 060  14F0A                          COMPARE UART_data[sF], character_LF[0A]        ;test for end of line
 061  2B000                          RETURN Z
 062  013F0                          LOAD s3, UART_data[sF]                         ;upper nibble character
 063  30142                          CALL read_from_UART[142]                       ;read character
 064  012F0                          LOAD s2, UART_data[sF]                         ;lower nibble character
 065  30197                          CALL ASCII_byte_to_hex[197]                    ;convert to true hex value
 066  2F0E0                          STORE s0, (sE)                                 ;write to SPM
 067  18E01                          ADD sE, 01                                     ;increment pointer
 068  3405D                          JUMP read_MCS_byte[05D]
 069                                 ;
 069                                 ;
 069                                 ;**************************************************************************************
 069                                 ;Determine the current address for the line of an MCS file in scratch pad memory
 069                                 ;**************************************************************************************
 069                                 ;
 069                                 ;Checks the existing line data stored in scratch pad memory starting at location
 069                                 ;'line_start' and determines the current address.
 069                                 ;
 069                                 ;The address is in the register set [s9,s8,s7] before and after this routine is
 069                                 ;executed because not all address bits are defined by a given line of MCS and
 069                                 ;the undefined bits remain constant.
 069                                 ;
 069                                 ;A record type of 04 will update [s9].
 069                                 ;A record type of 00 will update [s8,s7].
 069                                 ;
 069                                 ;On return, the register sB will contain the record type and
 069                                 ;register sC will indicate the number of data bytes stored.
 069                                 ;
 069  00D2B             MCS_address: LOAD sD, line_start[2B]                        ;initialise SPM memory pointer
 06A  07CD0                          FETCH sC, (sD)                                 ;read number of bytes on line
 06B  18D03                          ADD sD, 03                                     ;move to record type
 06C  07BD0                          FETCH sB, (sD)                                 ;read record type
 06D  14B00                          COMPARE sB, 00                                 ;test for data record
 06E  35074                          JUMP Z, new_low_address[074]
 06F  14B04                          COMPARE sB, 04                                 ;test for data record
 070  2B400                          RETURN NZ
 071  18D02                          ADD sD, 02                                     ;read upper 8-bits
 072  079D0                          FETCH s9, (sD)
 073  2A000                          RETURN
 074  1CD01         new_low_address: SUB sD, 01                                     ;read lower 8-bits
 075  077D0                          FETCH s7, (sD)
 076  1CD01                          SUB sD, 01                                     ;read middle 8-bits
 077  078D0                          FETCH s8, (sD)
 078  2A000                          RETURN
 079                                 ;
 079                                 ;
 079                                 ;**************************************************************************************
 079                                 ; Write to Buffer of StrataFlash Memory and program
 079                                 ;**************************************************************************************
 079                                 ;
 079                                 ; Writing to the buffer allows faster operation than writing individual bytes.
 079                                 ; The buffer size is limited to 32 locations. To perform a buffer write the process
 079                                 ; is as follows:-
 079                                 ;   Write command for buffer write to StrataFLASH memory (E8 hex).
 079                                 ;      Base address for writing should also be set.
 079                                 ;   Read Status register and if not ready repeat command until it is.
 079                                 ;   Write a value specifying the number of bytes to be written LESS ONE.
 079                                 ;      In this program the number of bytes will be specified in register sA
 079                                 ;      and this value needs to be decremented before writing to the memory.
 079                                 ;   Write the correct number of actual data bytes with appropriate addresses.
 079                                 ;      Ideally the addresses do not cross the boundary of 32 locations
 079                                 ;      such that LSBs are always in the range 00000 to 11111 binary.
 079                                 ;      Crossing the boundary is OK but will take longer to program.
 079                                 ;   Write command to confirm operation (D0 hex).
 079                                 ;   Read Status register and wait for ready.
 079                                 ;
 079                                 ;   This routine additionally restores the normal read array mode before returning.
 079                                 ;
 079                                 ; The number of bytes to be written should be supplied in register sA and must be
 079                                 ; a value between 1 and 32 (01 and 20 hex).
 079                                 ;
 079                                 ; The 24-bit base address should be supplied in register set [s9,s8,s7].
 079                                 ; On return, this will be increased by the number of locations written.
 079                                 ;
 079                                 ; Scratch pad memory locations starting at location defined by constant
 079                                 ; 'data_start' should contain the data bytes to be written.
 079                                 ;
 079                                 ; The act of writing the buffer to the memory array may take up to 654us to complete.
 079                                 ; The time taken to program is recorded by register pair [sE,sD]. Each count
 079                                 ; equates to 15 instructions which is equivalent to 30 clock cycles (600ns at 50MHz).
 079                                 ;
 079                                 ; Registers used s0,s1,s7,s8,s9,sA,sD,sE
 079                                 ;
 079                                 ;
 079  001E8         SF_buffer_write: LOAD s1, E8                                    ;command for buffer write
 07A  3010D                          CALL SF_byte_write[10D]
 07B  30103                          CALL SF_byte_read[103]                         ;read status register into s0
 07C  12080                          TEST s0, 80                                    ;test ready/busy flag
 07D  35079                          JUMP Z, SF_buffer_write[079]                   ;repeat command until ready
 07E  011A0                          LOAD s1, sA                                    ;Specify number of bytes to write
 07F  1C101                          SUB s1, 01                                     ;one less than actual number!
 080  3010D                          CALL SF_byte_write[10D]
 081  0032F                          LOAD s3, data_start[2F]                        ;point to data in scratch pad memory
 082  07130       write_buffer_loop: FETCH s1, (s3)                                 ;fetch data
 083  3010D                          CALL SF_byte_write[10D]                        ;write to buffer
 084  18701                          ADD s7, 01                                     ;increment address
 085  1A800                          ADDCY s8, 00
 086  1A900                          ADDCY s9, 00
 087  18301                          ADD s3, 01                                     ;increment SPM pointer
 088  1CA01                          SUB sA, 01                                     ;count bytes remaining
 089  35482                          JUMP NZ, write_buffer_loop[082]
 08A  001D0                          LOAD s1, D0                                    ;command to confirm write
 08B  3010D                          CALL SF_byte_write[10D]
 08C  3011A                          CALL wait_SF_ready[11A]                        ;wait for program to complete and set read array mode
 08D  2A000                          RETURN
 08E                                 ;
 08E                                 ;
 08E                                 ;**************************************************************************************
 08E                                 ; Write Command - Write one byte to specified address
 08E                                 ;**************************************************************************************
 08E                                 ;
 08E  30321           write_command: CALL send_address[321]                         ;obtain 24-bit address 000000 to FFFFFF
 08F  301B0                          CALL obtain_8bits[1B0]
 090  3588E                          JUMP C, write_command[08E]                     ;bad input address
 091  01900                          LOAD s9, s0
 092  301B0                          CALL obtain_8bits[1B0]
 093  3588E                          JUMP C, write_command[08E]                     ;bad input address
 094  01800                          LOAD s8, s0
 095  301B0                          CALL obtain_8bits[1B0]
 096  3588E                          JUMP C, write_command[08E]                     ;bad input address
 097  01700                          LOAD s7, s0
 098  30331                get_data: CALL send_data[331]                            ;obtain 8-bit data 00 to FF into s0
 099  301B0                          CALL obtain_8bits[1B0]
 09A  35898                          JUMP C, get_data[098]                          ;bad input data
 09B  3009F                          CALL SF_single_byte_write[09F]
 09C  301B6                          CALL send_CR[1B6]
 09D  3024F                          CALL send_OK[24F]
 09E  34007                          JUMP prompt[007]
 09F                                 ;
 09F                                 ;
 09F                                 ;**************************************************************************************
 09F                                 ; Write a single byte to StrataFlash Memory
 09F                                 ;**************************************************************************************
 09F                                 ;
 09F                                 ; To write a single byte to StrataFLASH memory the address must be set and the
 09F                                 ; single-word/byte program command (40 hex) sent to the memory. Then the data byte can
 09F                                 ; be written to the memory using the same address.
 09F                                 ;
 09F                                 ; The 24-bit address should be supplied in register set [s9,s8,s7].
 09F                                 ; Register s0 should contain the byte data to be written to the memory.
 09F                                 ;
 09F                                 ; The act of writing the memory array may take up to 175us to complete. This routine
 09F                                 ; waits for the memory to be ready before restoring the normal read array mode and
 09F                                 ; returning. The time taken to program is recorded by register pair [sE,sD]. Each count
 09F                                 ; equates to 15 instructions which is equivalent to 30 clock cycles (600ns at 50MHz).
 09F                                 ;
 09F                                 ; Registers used s0,s1,s7,s8,s9,sD,sE   (s7,s8,s9 not changed)
 09F                                 ;
 09F                                 ; Registers used s0,s1,s7,s8,s9
 09F                                 ;
 09F  00140    SF_single_byte_write: LOAD s1, 40                                    ;command for single byte program
 0A0  3010D                          CALL SF_byte_write[10D]
 0A1  01100                          LOAD s1, s0                                    ;write data to be programmed
 0A2  3010D                          CALL SF_byte_write[10D]
 0A3  3011A                          CALL wait_SF_ready[11A]                        ;wait for program to complete
 0A4  2A000                          RETURN
 0A5                                 ;
 0A5                                 ;
 0A5                                 ;**************************************************************************************
 0A5                                 ;Read Command - Read one page of memory at specified address
 0A5                                 ;**************************************************************************************
 0A5                                 ;
 0A5  30321            read_command: CALL send_address[321]                         ;obtain 24-bit address 000000 to FFFFFF.  ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0A6  301B0                          CALL obtain_8bits[1B0]                         ;read value from UART
 0A7  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0A8  01900                          LOAD s9, s0
 0A9  301B0                          CALL obtain_8bits[1B0]
 0AA  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0AB  01800                          LOAD s8, s0
 0AC  301B0                          CALL obtain_8bits[1B0]
 0AD  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0AE  01700                          LOAD s7, s0
 0AF  301B6                          CALL send_CR[1B6]
 0B0  300B3                          CALL send_SF_page[0B3]                         ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B1  3024F                          CALL send_OK[24F]                              ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B2  34007                          JUMP prompt[007]                               ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B3                                 ;
 0B3                                 ;The start address should be provided in register set [s9,s8,s7].
 0B3                                 ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
 0B3                                 ;with each line commencing with the address of the first byte.
 0B3                                 ;
 0B3  00610            send_SF_page: LOAD s6, 10                                    ;16 lines to display
 0B4  301B6            send_SF_line: CALL send_CR[1B6]                              ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B5  30190                          CALL send_hex_3bytes[190]                      ;display address                    ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B6  301B9                          CALL send_space[1B9]                           ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B7  00510                          LOAD s5, 10                                    ;16 bytes to display on a line      ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B8  301B9            send_SF_byte: CALL send_space[1B9]                           ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0B9  30103                          CALL SF_byte_read[103]                         ;read byte into s0                  ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BA  18701                          ADD s7, 01                                     ;increment StrataFLASH address      ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BB  1A800                          ADDCY s8, 00                                   ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BC  1A900                          ADDCY s9, 00                                   ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BD  3018A                          CALL send_hex_byte[18A]                        ;display byte                       ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BE  1C501                          SUB s5, 01                                     ;count bytes per line               ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0BF  354B8                          JUMP NZ, send_SF_byte[0B8]                     ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C0  1C601                          SUB s6, 01                                     ;count lines                        ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C1  354B4                          JUMP NZ, send_SF_line[0B4]                     ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C2  301B6                          CALL send_CR[1B6]                              ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C3  2A000                          RETURN                                         ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C4                                 ;
 0C4                                 ;
 0C4                                 ;;**************************************************************************************
 0C4                                 ;Leer Archivo completo- lee el archivo completo
 0C4                                 ;**************************************************************************************
 0C4                                 ;
 0C4  30321            arch_command: CALL send_address[321]                         ;obtain 24-bit address 000000 to FFFFFF.  ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0C5  301B0                          CALL obtain_8bits[1B0]                         ;read value from UART
 0C6  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0C7  01900                          LOAD s9, s0
 0C8  301B0                          CALL obtain_8bits[1B0]
 0C9  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0CA  01800                          LOAD s8, s0
 0CB  301B0                          CALL obtain_8bits[1B0]
 0CC  358A5                          JUMP C, read_command[0A5]                      ;bad input address
 0CD  01700                          LOAD s7, s0
 0CE  301B6                          CALL send_CR[1B6]
 0CF  300D2                          CALL send_SF_page2[0D2]                        ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D0  3024F                          CALL send_OK[24F]                              ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D1  34007                          JUMP prompt[007]                               ;revisado incluyendo cada call, no mas de s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D2                                 ;
 0D2                                 ;The start address should be provided in register set [s9,s8,s7].
 0D2                                 ;The display will be next 256 bytes displayed as 16 lines of 16 bytes
 0D2                                 ;with each line commencing with the address of the first byte.
 0D2                                 ;
 0D2  006FF           send_SF_page2: LOAD s6, FF                                    ; CONTADOR INTERNO (valor inicial de 255)
 0D3  00446                          LOAD s4, 46                                    ; CONTADOR EXTERNO (Valor inicial de 70): En total 17737 lines to display
 0D4  301B6           send_SF_line2: CALL send_CR[1B6]                              ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D5  30190                          CALL send_hex_3bytes[190]                      ;display address                    ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D6  301B9                          CALL send_space[1B9]                           ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D7  00510                          LOAD s5, 10                                    ;16 bytes to display on a line      ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D8  301B9           send_SF_byte2: CALL send_space[1B9]                           ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0D9  30103                          CALL SF_byte_read[103]                         ;read byte into s0                  ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DA  18701                          ADD s7, 01                                     ;increment StrataFLASH address      ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DB  1A800                          ADDCY s8, 00                                   ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DC  1A900                          ADDCY s9, 00                                   ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DD  3018A                          CALL send_hex_byte[18A]                        ;display byte                       ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DE  1C501                          SUB s5, 01                                     ;count bytes per line               ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0DF  354D8                          JUMP NZ, send_SF_byte2[0D8]                    ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0E0  1C601                          SUB s6, 01                                     ;count lines                        ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0E1  1E400                          SUBCY s4, 00
 0E2  354D4                          JUMP NZ, send_SF_line2[0D4]                    ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0E3  301B6                          CALL send_CR[1B6]                              ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0E4  2A000                          RETURN                                         ;revisado incluyendo cada call, se usan s0,s1,s2,s5,s6,s7,s8,s9,sF
 0E5                                 ;
 0E5                                 ;
 0E5                                 ;
 0E5                                 ;**************************************************************************************
 0E5                                 ; ID Command - Read and display the device information for the StrataFLASH FLASH memory
 0E5                                 ;**************************************************************************************
 0E5                                 ;
 0E5                                 ; Normal response should be
 0E5                                 ;   Device Manufacturer Code (Intel) = 89 hex
 0E5                                 ;   Memory ID code for 128Mbit = 18 hex
 0E5                                 ;
 0E5                                 ; To read the device information the Read device information command (90)
 0E5                                 ; must be written to the memory. The information is read back but assumes
 0E5                                 ; that 16-bit words are being used and hence address bit0 is not really used.
 0E5                                 ; hence addresses 000000 and 0000001 both return the Device Manufacturer Code and
 0E5                                 ; addresses 000002 and 0000003 both return the Memory ID code.
 0E5                                 ;
 0E5                                 ; After reading the device information the read array command is written to the
 0E5                                 ; device to put it back to normal read mode.
 0E5                                 ;
 0E5                                 ; Registers used s0,s7,s8,s9
 0E5                                 ;
 0E5  301B6          SF_information: CALL send_CR[1B6]                              ;send 'ID=' to terminal
 0E6  302E9                          CALL send_ID[2E9]
 0E7  00F3D                          LOAD UART_data[sF], character_equals[3D]
 0E8  30154                          CALL send_to_UART[154]
 0E9  301B9                          CALL send_space[1B9]
 0EA  00900                          LOAD s9, 00                                    ;define base address 000000
 0EB  00800                          LOAD s8, 00
 0EC  00700                          LOAD s7, 00
 0ED  00190                          LOAD s1, 90                                    ;command to read device information
 0EE  3010D                          CALL SF_byte_write[10D]
 0EF  30103                          CALL SF_byte_read[103]                         ;read Device Manufacturer Code into s0
 0F0  3018A                          CALL send_hex_byte[18A]                        ;display byte
 0F1  301B9                          CALL send_space[1B9]
 0F2  00702                          LOAD s7, 02                                    ;change address
 0F3  30103                          CALL SF_byte_read[103]                         ;read Memory ID code into s0
 0F4  3018A                          CALL send_hex_byte[18A]                        ;display byte
 0F5  301B6                          CALL send_CR[1B6]
 0F6  30117                          CALL set_SF_read_array_mode[117]               ;restore normal read array mode
 0F7  34007                          JUMP prompt[007]
 0F8                                 ;
 0F8                                 ;
 0F8                                 ;**************************************************************************************
 0F8                                 ; Read StrataFLASH status register
 0F8                                 ;**************************************************************************************
 0F8                                 ;
 0F8                                 ; The main reason for reading the status register is to determine when the memory
 0F8                                 ; is ready or busy. This information is provided by bit7 (0=busy and 1=ready).
 0F8                                 ;
 0F8                                 ; The lower bits all indicate errors of some kind and therefore the only desirable
 0F8                                 ; response is 00 hex or 80 hex. In this program, no error checking or clearing
 0F8                                 ; is performed and the way this routine is executed from the menu only 80 hex is
 0F8                                 ; expected.
 0F8                                 ;
 0F8                                 ; To read the status register the read status register command must be written to
 0F8                                 ; the device. All subsequent reads are then result in the return of the status
 0F8                                 ; register. A different read command must be written to the device to stop this
 0F8                                 ; mode.
 0F8                                 ;
 0F8                                 ; This mode is also entered automatically when performing program and erase operations.
 0F8                                 ;
 0F8  00900               SF_status: LOAD s9, 00                                    ;define base address 000000
 0F9  00800                          LOAD s8, 00
 0FA  00700                          LOAD s7, 00
 0FB  00170                          LOAD s1, 70                                    ;command to read status register
 0FC  3010D                          CALL SF_byte_write[10D]
 0FD  301B6                          CALL send_CR[1B6]
 0FE  30103                          CALL SF_byte_read[103]                         ;read status register into s0
 0FF  3018A                          CALL send_hex_byte[18A]                        ;display byte
 100  301B6                          CALL send_CR[1B6]
 101  30117                          CALL set_SF_read_array_mode[117]
 102  34007                          JUMP prompt[007]
 103                                 ;
 103                                 ;
 103                                 ;**************************************************************************************
 103                                 ; Read a byte from StrataFlash Memory
 103                                 ;**************************************************************************************
 103                                 ;
 103                                 ; The 24-bit address should be supplied in register set [s9,s8,s7].
 103                                 ; Register s0 will return the byte data retrieved from the memory.
 103                                 ;
 103                                 ; To read a byte, the address needs to be set up on the address lines
 103                                 ; and the controls set as follows
 103                                 ;    SF_read = 1 - disable Spartan data outputs and enable StrataFlash outputs (OE=0)
 103                                 ;      SF_ce = 0 - enable StrataFLASH memory
 103                                 ;      SF_we = 1 - Write enable off
 103                                 ;
 103                                 ; The access time of the memory is 75ns. This is equivalent to 3.75 clock cycles at
 103                                 ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
 103                                 ; provides adequate delay for the memory to be accessed.
 103                                 ;
 103                                 ; Registers used s0,s1,s7,s8,s9
 103                                 ;
 103  2C980            SF_byte_read: OUTPUT s9, SF_addr_hi_port[80]                 ;set 24-bit address
 104  2C840                          OUTPUT s8, SF_addr_mi_port[40]
 105  2C720                          OUTPUT s7, SF_addr_lo_port[20]
 106  00105                          LOAD s1, 05                                    ;set controls
 107  2C108                          OUTPUT s1, SF_control_port[08]
 108  00106                          LOAD s1, 06                                    ;>75ns delay
 109  00106                          LOAD s1, 06                                    ;but do something useful!
 10A  04002                          INPUT s0, SF_data_in_port[02]                  ;read data byte
 10B  2C108                          OUTPUT s1, SF_control_port[08]                 ;clear controls
 10C  2A000                          RETURN
 10D                                 ;
 10D                                 ;
 10D                                 ;**************************************************************************************
 10D                                 ; Write data or command byte to StrataFlash Memory
 10D                                 ;**************************************************************************************
 10D                                 ;
 10D                                 ; The 24-bit address should be supplied in register set [s9,s8,s7].
 10D                                 ; Register s1 should contain the byte to be written to the memory.
 10D                                 ;
 10D                                 ; To write a byte, the address needs to be set up on the address lines
 10D                                 ; and the controls set as follows
 10D                                 ;    SF_read = 0 - enable Spartan data outputs and disable StrataFlash outputs (OE=1)
 10D                                 ;      SF_ce = 0 - enable StrataFLASH memory
 10D                                 ;      SF_we = 0 - Write enable on
 10D                                 ;
 10D                                 ; The setup time of the memory is 60ns. This is equivalent to 3 clock cycles at
 10D                                 ; 50MHz. Since each KCPSM3 instruction takes 2 clock cycles to execute, two instructions
 10D                                 ; provides adequate delay for the memory.
 10D                                 ;
 10D                                 ; Registers used s1,s7,s8,s9
 10D                                 ;
 10D  2C980           SF_byte_write: OUTPUT s9, SF_addr_hi_port[80]                 ;set 24-bit address
 10E  2C840                          OUTPUT s8, SF_addr_mi_port[40]
 10F  2C720                          OUTPUT s7, SF_addr_lo_port[20]
 110  2C110                          OUTPUT s1, SF_data_out_port[10]                ;set data byte to be written
 111  00100                          LOAD s1, 00                                    ;set controls
 112  2C108                          OUTPUT s1, SF_control_port[08]
 113  00106                          LOAD s1, 06                                    ;>60ns delay
 114  00106                          LOAD s1, 06                                    ;but do something useful!
 115  2C108                          OUTPUT s1, SF_control_port[08]                 ;clear controls
 116  2A000                          RETURN
 117                                 ;
 117                                 ;
 117                                 ;**************************************************************************************
 117                                 ; Set 'Read Array' mode on StrataFLASH
 117                                 ;**************************************************************************************
 117                                 ;
 117                                 ; The read array mode is the default mode of the memory and allows the contents
 117                                 ; of the memory to be read based on the supplied address.
 117                                 ;
 117                                 ; Read array is the default mode of the device, but it must also be placed back
 117                                 ; into this mode after programming, erasing or reading the status register.
 117                                 ;
 117                                 ; The read array command (FF hex) is written to the Strata flash memory.
 117                                 ;
 117                                 ; Registers used s1,s7,s8,s9
 117                                 ;
 117  001FF  set_SF_read_array_mode: LOAD s1, FF                                    ;command to read array
 118  3010D                          CALL SF_byte_write[10D]
 119  2A000                          RETURN
 11A                                 ;
 11A                                 ;
 11A                                 ;**************************************************************************************
 11A                                 ; Wait for StrataFLASH to be ready
 11A                                 ;**************************************************************************************
 11A                                 ;
 11A                                 ; This routine will typically be used after instigating a program or erase
 11A                                 ; command. It continuously reads the StrataFLASH status register and tests the
 11A                                 ; information provided by bit7 which indicates if the memory is busy(0) or ready(1).
 11A                                 ; The routine waits for the ready condition before sending a read array command
 11A                                 ; which puts the memory back to normal read mode.
 11A                                 ;
 11A                                 ; During the polling process, a counter formed by register pair [sE,sD] records
 11A                                 ; approximately how long the memory is busy. This can be used to evaluate programming
 11A                                 ; and erase times if required. The timing loop is 15 instructions which is equivalent
 11A                                 ; to 30 clock cycles (600ns at 50MHz)
 11A                                 ;
 11A                                 ; Registers used s0,s1,s7,s8,s9,sD,sE   (s7,s8,s9 not changed)
 11A                                 ;
 11A                                 ;
 11A  00E00           wait_SF_ready: LOAD sE, 00                                    ;clear 16-bit counter timer
 11B  00D00                          LOAD sD, 00
 11C  18D01            wait_SF_loop: ADD sD, 01                                     ;increment counter timer
 11D  1AE00                          ADDCY sE, 00
 11E  30103                          CALL SF_byte_read[103]                         ;read status register into s0
 11F  12080                          TEST s0, 80                                    ;test ready/busy flag
 120  3511C                          JUMP Z, wait_SF_loop[11C]
 121  30117                          CALL set_SF_read_array_mode[117]               ;restore normal read array mode
 122  2A000                          RETURN
 123                                 ;
 123                                 ;
 123                                 ;**************************************************************************************
 123                                 ; Send 16-bit value in register pair [sE,sD] to UART
 123                                 ;**************************************************************************************
 123                                 ;
 123                                 ; In this program the register pair [sE,sD] indicates the programming time of the
 123                                 ; StrataFLASH memory in 600ns increments. This routine can be used to display that
 123                                 ; value if required.
 123                                 ;
 123  301B6      send_counter_timer: CALL send_CR[1B6]
 124  010E0                          LOAD s0, sE
 125  3018A                          CALL send_hex_byte[18A]
 126  010D0                          LOAD s0, sD
 127  3018A                          CALL send_hex_byte[18A]
 128  301B6                          CALL send_CR[1B6]
 129  2A000                          RETURN
 12A                                 ;
 12A                                 ;
 12A                                 ;**************************************************************************************
 12A                                 ;Software delay routines
 12A                                 ;**************************************************************************************
 12A                                 ;
 12A                                 ;Delay of 1us.
 12A                                 ;
 12A                                 ;Constant value defines reflects the clock applied to KCPSM3. Every instruction
 12A                                 ;executes in 2 clock cycles making the calculation highly predictable. The '6' in
 12A                                 ;the following equation even allows for 'CALL delay_1us' instruction in the initiating code.
 12A                                 ;
 12A                                 ; delay_1us_constant =  (clock_rate - 6)/4       Where 'clock_rate' is in MHz
 12A                                 ;
 12A                                 ;Registers used s0
 12A                                 ;
 12A  0000B               delay_1us: LOAD s0, delay_1us_constant[0B]
 12B  1C001                wait_1us: SUB s0, 01
 12C  3552B                          JUMP NZ, wait_1us[12B]
 12D  2A000                          RETURN
 12E                                 ;
 12E                                 ;Delay of 40us.
 12E                                 ;
 12E                                 ;Registers used s0, s1
 12E                                 ;
 12E  00128              delay_40us: LOAD s1, 28                                    ;40 x 1us = 40us
 12F  3012A               wait_40us: CALL delay_1us[12A]
 130  1C101                          SUB s1, 01
 131  3552F                          JUMP NZ, wait_40us[12F]
 132  2A000                          RETURN
 133                                 ;
 133                                 ;
 133                                 ;Delay of 1ms.
 133                                 ;
 133                                 ;Registers used s0, s1, s2
 133                                 ;
 133  00219               delay_1ms: LOAD s2, 19                                    ;25 x 40us = 1ms
 134  3012E                wait_1ms: CALL delay_40us[12E]
 135  1C201                          SUB s2, 01
 136  35534                          JUMP NZ, wait_1ms[134]
 137  2A000                          RETURN
 138                                 ;
 138                                 ;Delay of 20ms.
 138                                 ;
 138                                 ;Delay of 20ms used during initialisation.
 138                                 ;
 138                                 ;Registers used s0, s1, s2, s3
 138                                 ;
 138  00314              delay_20ms: LOAD s3, 14                                    ;20 x 1ms = 20ms
 139  30133               wait_20ms: CALL delay_1ms[133]
 13A  1C301                          SUB s3, 01
 13B  35539                          JUMP NZ, wait_20ms[139]
 13C  2A000                          RETURN
 13D                                 ;
 13D                                 ;Delay of approximately 1 second.
 13D                                 ;
 13D                                 ;Registers used s0, s1, s2, s3, s4
 13D                                 ;
 13D  00414                delay_1s: LOAD s4, 14                                    ;50 x 20ms = 1000ms
 13E  30138                 wait_1s: CALL delay_20ms[138]
 13F  1C401                          SUB s4, 01
 140  3553E                          JUMP NZ, wait_1s[13E]
 141  2A000                          RETURN
 142                                 ;
 142                                 ;
 142                                 ;**************************************************************************************
 142                                 ;UART communication routines
 142                                 ;**************************************************************************************
 142                                 ;
 142                                 ;Read one character from the UART
 142                                 ;
 142                                 ;Character read will be returned in a register called 'UART_data'.
 142                                 ;
 142                                 ;The routine first tests the receiver FIFO buffer to see if data is present.
 142                                 ;If the FIFO is empty, the routine waits until there is a character to read.
 142                                 ;As this could take any amount of time the wait loop could include a call to a
 142                                 ;subroutine which performs a useful function.
 142                                 ;
 142                                 ;If the received character is an XOFF, then the routine will then wait
 142                                 ;for an XON to be received. This means that the rest of the program is held
 142                                 ;in suspense and therefore it can not transmit. Once an XON is received, it will
 142                                 ;again wait for a normal character before returning.
 142                                 ;
 142                                 ;NOTE: Characters between the XOFF and XON will be ignored in this version of the
 142                                 ;program!!!
 142                                 ;
 142                                 ;Interrupt is disabled during this routine to prevent a false situation. If the
 142                                 ;receiver half-full flag went High it should result in an interrupt transmitting
 142                                 ;an XOFF character. However, if this routine were able to read the receiver buffer
 142                                 ;at just about the same as the hardware detects the half-full flag, then it could
 142                                 ;think that an XON needs to be transmitted.
 142                                 ;
 142                                 ;
 142                                 ;Registers used s0 and UART_data
 142                                 ;
 142  3C000          read_from_UART: DISABLE INTERRUPT
 143  04000       wait_Rx_character: INPUT s0, status_port[00]                      ;test Rx_FIFO buffer
 144  12008                          TEST s0, rx_data_present[08]
 145  35547                          JUMP NZ, read_character[147]
 146  34143                          JUMP wait_Rx_character[143]
 147  04F01          read_character: INPUT UART_data[sF], UART_read_port[01]        ;read from FIFO
 148  14F13                          COMPARE UART_data[sF], character_XOFF[13]      ;test for XOFF
 149  3514C                          JUMP Z, wait_XON[14C]
 14A  3C001                          ENABLE INTERRUPT                               ;normal finish
 14B  2A000                          RETURN
 14C  04000                wait_XON: INPUT s0, status_port[00]                      ;test Rx_FIFO buffer
 14D  12008                          TEST s0, rx_data_present[08]
 14E  35550                          JUMP NZ, read_XON[150]
 14F  3414C                          JUMP wait_XON[14C]
 150  04F01                read_XON: INPUT UART_data[sF], UART_read_port[01]        ;read from FIFO
 151  14F11                          COMPARE UART_data[sF], character_XON[11]       ;test for XON
 152  35143                          JUMP Z, wait_Rx_character[143]                 ;now wait for normal character
 153  3414C                          JUMP wait_XON[14C]                             ;continue to wait for XON
 154                                 ;
 154                                 ;
 154                                 ;
 154                                 ;Transmit one character to the UART
 154                                 ;
 154                                 ;Character supplied in register called 'UART_data'.
 154                                 ;
 154                                 ;The routine first tests the transmit FIFO buffer is empty.
 154                                 ;If the FIFO currently has any data, the routine waits until it is empty.
 154                                 ;Ultimately this means that only one character is sent at a time which
 154                                 ;could be important if the PC at the other end of the link transmits
 154                                 ;an XOFF and needs the flow of data to terminate as soon as possible.
 154                                 ;
 154                                 ;Registers used s0
 154                                 ;
 154  04000            send_to_UART: INPUT s0, status_port[00]                      ;test Tx_FIFO buffer
 155  12001                          TEST s0, tx_data_present[01]
 156  35158                          JUMP Z, UART_write[158]
 157  34154                          JUMP send_to_UART[154]
 158  2CF04              UART_write: OUTPUT UART_data[sF], UART_write_port[04]
 159  2A000                          RETURN
 15A                                 ;
 15A                                 ;
 15A                                 ;**************************************************************************************
 15A                                 ;Useful ASCII conversion and handling routines
 15A                                 ;**************************************************************************************
 15A                                 ;
 15A                                 ;Convert value provided in register s0 into ASCII characters
 15A                                 ;
 15A                                 ;The value provided must in the range 0 to 99 and will be converted into
 15A                                 ;two ASCII characters.
 15A                                 ;     The number of 'tens' will be represented by an ASCII character returned in register s1.
 15A                                 ;     The number of 'units' will be represented by an ASCII character returned in register s0.
 15A                                 ;
 15A                                 ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex added to
 15A                                 ;the actual decimal value.
 15A                                 ;
 15A                                 ;Registers used s0 and s1.
 15A                                 ;
 15A  00130        decimal_to_ASCII: LOAD s1, 30                                    ;load 'tens' counter with ASCII for '0'
 15B  18101            test_for_ten: ADD s1, 01                                     ;increment 'tens' value
 15C  1C00A                          SUB s0, 0A                                     ;try to subtract 10 from the supplied value
 15D  35D5B                          JUMP NC, test_for_ten[15B]                     ;repeat if subtraction was possible without underflow.
 15E  1C101                          SUB s1, 01                                     ;'tens' value one less ten due to underflow
 15F  1803A                          ADD s0, 3A                                     ;restore units value (the remainder) and convert to ASCII
 160  2A000                          RETURN
 161                                 ;
 161                                 ;
 161                                 ;
 161                                 ;Convert character to upper case
 161                                 ;
 161                                 ;The character supplied in register s0.
 161                                 ;If the character is in the range 'a' to 'z', it is converted
 161                                 ;to the equivalent upper case character in the range 'A' to 'Z'.
 161                                 ;All other characters remain unchanged.
 161                                 ;
 161                                 ;Registers used s0.
 161                                 ;
 161  14061              upper_case: COMPARE s0, 61                                 ;eliminate character codes below 'a' (61 hex)
 162  2B800                          RETURN C
 163  1407B                          COMPARE s0, 7B                                 ;eliminate character codes above 'z' (7A hex)
 164  2BC00                          RETURN NC
 165  0A0DF                          AND s0, DF                                     ;mask bit5 to convert to upper case
 166  2A000                          RETURN
 167                                 ;
 167                                 ;
 167                                 ;Convert character '0' to '9' to numerical value in range 0 to 9
 167                                 ;
 167                                 ;The character supplied in register s0. If the character is in the
 167                                 ;range '0' to '9', it is converted to the equivalent decimal value.
 167                                 ;Characters not in the range '0' to '9' are signified by the return
 167                                 ;with the CARRY flag set.
 167                                 ;
 167                                 ;Registers used s0.
 167                                 ;
 167  180C6          1char_to_value: ADD s0, C6                                     ;reject character codes above '9' (39 hex)
 168  2B800                          RETURN C                                       ;carry flag is set
 169  1C0F6                          SUB s0, F6                                     ;reject character codes below '0' (30 hex)
 16A  2A000                          RETURN                                         ;carry is set if value not in range
 16B                                 ;
 16B                                 ;
 16B                                 ;Determine the numerical value of a two character decimal string held in
 16B                                 ;scratch pad memory such the result is in the range 0 to 99 (00 to 63 hex).
 16B                                 ;
 16B                                 ;The string must be stored in two consecutive memory locations and the
 16B                                 ;location of the first (tens) character supplied in the s1 register.
 16B                                 ;The result is provided in register s2. Strings not using characters in the
 16B                                 ;range '0' to '9' are signified by the return with the CARRY flag set.
 16B                                 ;
 16B                                 ;Registers used s0, s1 and s2.
 16B                                 ;
 16B  07010          2char_to_value: FETCH s0, (s1)                                 ;read 'tens' character
 16C  30167                          CALL 1char_to_value[167]                       ;convert to numerical value
 16D  2B800                          RETURN C                                       ;bad character - CARRY set
 16E  01200                          LOAD s2, s0
 16F  20206                          SL0 s2                                         ;multiply 'tens' value by 10 (0A hex)
 170  20206                          SL0 s2
 171  19200                          ADD s2, s0
 172  20206                          SL0 s2
 173  18101                          ADD s1, 01                                     ;read 'units' character
 174  07010                          FETCH s0, (s1)
 175  30167                          CALL 1char_to_value[167]                       ;convert to numerical value
 176  2B800                          RETURN C                                       ;bad character - CARRY set
 177  19200                          ADD s2, s0                                     ;add units to result and clear CARRY flag
 178  2A000                          RETURN
 179                                 ;
 179                                 ;
 179                                 ;Convert hexadecimal value provided in register s0 into ASCII characters
 179                                 ;
 179                                 ;The value provided must can be any value in the range 00 to FF and will be converted into
 179                                 ;two ASCII characters.
 179                                 ;     The upper nibble will be represented by an ASCII character returned in register s2.
 179                                 ;     The lower nibble will be represented by an ASCII character returned in register s1.
 179                                 ;
 179                                 ;The ASCII representations of '0' to '9' are 30 to 39 hexadecimal which is simply 30 hex
 179                                 ;added to the actual decimal value. The ASCII representations of 'A' to 'F' are 41 to 46
 179                                 ;hexadecimal requiring a further addition of 07 to the 30 already added.
 179                                 ;
 179                                 ;Registers used s0, s1 and s2.
 179                                 ;
 179  01100       hex_byte_to_ASCII: LOAD s1, s0                                    ;remember value supplied
 17A  2000E                          SR0 s0                                         ;isolate upper nibble
 17B  2000E                          SR0 s0
 17C  2000E                          SR0 s0
 17D  2000E                          SR0 s0
 17E  30185                          CALL hex_to_ASCII[185]                         ;convert
 17F  01200                          LOAD s2, s0                                    ;upper nibble value in s2
 180  01010                          LOAD s0, s1                                    ;restore complete value
 181  0A00F                          AND s0, 0F                                     ;isolate lower nibble
 182  30185                          CALL hex_to_ASCII[185]                         ;convert
 183  01100                          LOAD s1, s0                                    ;lower nibble value in s1
 184  2A000                          RETURN
 185                                 ;
 185                                 ;Convert hexadecimal value provided in register s0 into ASCII character
 185                                 ;
 185                                 ;Register used s0
 185                                 ;
 185  1C00A            hex_to_ASCII: SUB s0, 0A                                     ;test if value is in range 0 to 9
 186  35988                          JUMP C, number_char[188]
 187  18007                          ADD s0, 07                                     ;ASCII char A to F in range 41 to 46
 188  1803A             number_char: ADD s0, 3A                                     ;ASCII char 0 to 9 in range 30 to 40
 189  2A000                          RETURN
 18A                                 ;
 18A                                 ;
 18A                                 ;Send the two character HEX value of the register contents 's0' to the UART
 18A                                 ;
 18A                                 ;Registers used s0, s1, s2
 18A                                 ;
 18A  30179           send_hex_byte: CALL hex_byte_to_ASCII[179]
 18B  01F20                          LOAD UART_data[sF], s2
 18C  30154                          CALL send_to_UART[154]
 18D  01F10                          LOAD UART_data[sF], s1
 18E  30154                          CALL send_to_UART[154]
 18F  2A000                          RETURN
 190                                 ;
 190                                 ;
 190                                 ;
 190                                 ;Send the six character HEX value of the register contents [s9,s8,s7] to the UART
 190                                 ;
 190                                 ;Registers used s0, s1, s2
 190                                 ;
 190  01090         send_hex_3bytes: LOAD s0, s9
 191  3018A                          CALL send_hex_byte[18A]
 192  01080                          LOAD s0, s8
 193  3018A                          CALL send_hex_byte[18A]
 194  01070                          LOAD s0, s7
 195  3018A                          CALL send_hex_byte[18A]
 196  2A000                          RETURN
 197                                 ;
 197                                 ;
 197                                 ;Convert the HEX ASCII characters contained in 's3' and 's2' into
 197                                 ;an equivalent hexadecimal value in register 's0'.
 197                                 ;     The upper nibble is represented by an ASCII character in register s3.
 197                                 ;     The lower nibble is represented by an ASCII character in register s2.
 197                                 ;
 197                                 ;Input characters must be in the range 00 to FF hexadecimal or the CARRY flag
 197                                 ;will be set on return.
 197                                 ;
 197                                 ;Registers used s0, s2 and s3.
 197                                 ;
 197  01030       ASCII_byte_to_hex: LOAD s0, s3                                    ;Take upper nibble
 198  301A4                          CALL ASCII_to_hex[1A4]                         ;convert to value
 199  2B800                          RETURN C                                       ;reject if out of range
 19A  01300                          LOAD s3, s0                                    ;remember value
 19B  20306                          SL0 s3                                         ;multiply value by 16 to put in upper nibble
 19C  20306                          SL0 s3
 19D  20306                          SL0 s3
 19E  20306                          SL0 s3
 19F  01020                          LOAD s0, s2                                    ;Take lower nibble
 1A0  301A4                          CALL ASCII_to_hex[1A4]                         ;convert to value
 1A1  2B800                          RETURN C                                       ;reject if out of range
 1A2  0D030                          OR s0, s3                                      ;merge in the upper nibble with CARRY reset
 1A3  2A000                          RETURN
 1A4                                 ;
 1A4                                 ;
 1A4                                 ;Routine to convert ASCII data in 's0' to an equivalent HEX value.
 1A4                                 ;
 1A4                                 ;If character is not valid for hex, then CARRY is set on return.
 1A4                                 ;
 1A4                                 ;Register used s0
 1A4                                 ;
 1A4  180B9            ASCII_to_hex: ADD s0, B9                                     ;test for above ASCII code 46 ('F')
 1A5  2B800                          RETURN C
 1A6  1C0E9                          SUB s0, E9                                     ;normalise 0 to 9 with A-F in 11 to 16 hex
 1A7  2B800                          RETURN C                                       ;reject below ASCII code 30 ('0')
 1A8  1C011                          SUB s0, 11                                     ;isolate A-F down to 00 to 05 hex
 1A9  35DAE                          JUMP NC, ASCII_letter[1AE]
 1AA  18007                          ADD s0, 07                                     ;test for above ASCII code 46 ('F')
 1AB  2B800                          RETURN C
 1AC  1C0F6                          SUB s0, F6                                     ;convert to range 00 to 09
 1AD  2A000                          RETURN
 1AE  1800A            ASCII_letter: ADD s0, 0A                                     ;convert to range 0A to 0F
 1AF  2A000                          RETURN
 1B0                                 ;
 1B0                                 ;
 1B0                                 ;Read two hex characters from UART and convert to single byte data
 1B0                                 ;
 1B0  30024            obtain_8bits: CALL read_upper_case[024]                      ;obtain one byte from UART
 1B1  01300                          LOAD s3, s0
 1B2  30024                          CALL read_upper_case[024]
 1B3  01200                          LOAD s2, s0
 1B4  30197                          CALL ASCII_byte_to_hex[197]
 1B5  2A000                          RETURN
 1B6                                 ;
 1B6                                 ;**************************************************************************************
 1B6                                 ;Text messages
 1B6                                 ;**************************************************************************************
 1B6                                 ;
 1B6                                 ;
 1B6                                 ;Send Carriage Return to the UART
 1B6                                 ;
 1B6  00F0D                 send_CR: LOAD UART_data[sF], character_CR[0D]
 1B7  30154                          CALL send_to_UART[154]
 1B8  2A000                          RETURN
 1B9                                 ;
 1B9                                 ;Send a space to the UART
 1B9                                 ;
 1B9  00F20              send_space: LOAD UART_data[sF], character_space[20]
 1BA  30154                          CALL send_to_UART[154]
 1BB  2A000                          RETURN
 1BC                                 ;
 1BC                                 ;
 1BC                                 ;Send 'PicoBlaze NOR FLASH Programmer' string to the UART
 1BC                                 ;
 1BC  301B6            send_welcome: CALL send_CR[1B6]
 1BD  301B6                          CALL send_CR[1B6]
 1BE  00F50                          LOAD UART_data[sF], character_P[50]
 1BF  30154                          CALL send_to_UART[154]
 1C0  00F69                          LOAD UART_data[sF], character_i[69]
 1C1  30154                          CALL send_to_UART[154]
 1C2  00F63                          LOAD UART_data[sF], character_c[63]
 1C3  30154                          CALL send_to_UART[154]
 1C4  00F6F                          LOAD UART_data[sF], character_o[6F]
 1C5  30154                          CALL send_to_UART[154]
 1C6  00F42                          LOAD UART_data[sF], character_B[42]
 1C7  30154                          CALL send_to_UART[154]
 1C8  00F6C                          LOAD UART_data[sF], character_l[6C]
 1C9  30154                          CALL send_to_UART[154]
 1CA  00F61                          LOAD UART_data[sF], character_a[61]
 1CB  30154                          CALL send_to_UART[154]
 1CC  00F7A                          LOAD UART_data[sF], character_z[7A]
 1CD  30154                          CALL send_to_UART[154]
 1CE  00F65                          LOAD UART_data[sF], character_e[65]
 1CF  30154                          CALL send_to_UART[154]
 1D0  301B9                          CALL send_space[1B9]
 1D1  00F4E                          LOAD UART_data[sF], character_N[4E]
 1D2  30154                          CALL send_to_UART[154]
 1D3  00F4F                          LOAD UART_data[sF], character_O[4F]
 1D4  30154                          CALL send_to_UART[154]
 1D5  00F52                          LOAD UART_data[sF], character_R[52]
 1D6  30154                          CALL send_to_UART[154]
 1D7  301B9                          CALL send_space[1B9]
 1D8  00F46                          LOAD UART_data[sF], character_F[46]
 1D9  30154                          CALL send_to_UART[154]
 1DA  00F4C                          LOAD UART_data[sF], character_L[4C]
 1DB  30154                          CALL send_to_UART[154]
 1DC  00F41                          LOAD UART_data[sF], character_A[41]
 1DD  30154                          CALL send_to_UART[154]
 1DE  00F53                          LOAD UART_data[sF], character_S[53]
 1DF  30154                          CALL send_to_UART[154]
 1E0  00F48                          LOAD UART_data[sF], character_H[48]
 1E1  30154                          CALL send_to_UART[154]
 1E2  301B9                          CALL send_space[1B9]
 1E3  00F50                          LOAD UART_data[sF], character_P[50]
 1E4  30154                          CALL send_to_UART[154]
 1E5  00F72                          LOAD UART_data[sF], character_r[72]
 1E6  30154                          CALL send_to_UART[154]
 1E7  00F6F                          LOAD UART_data[sF], character_o[6F]
 1E8  30154                          CALL send_to_UART[154]
 1E9  00F67                          LOAD UART_data[sF], character_g[67]
 1EA  30154                          CALL send_to_UART[154]
 1EB  00F72                          LOAD UART_data[sF], character_r[72]
 1EC  30154                          CALL send_to_UART[154]
 1ED  00F61                          LOAD UART_data[sF], character_a[61]
 1EE  30154                          CALL send_to_UART[154]
 1EF  00F6D                          LOAD UART_data[sF], character_m[6D]
 1F0  30154                          CALL send_to_UART[154]
 1F1  00F6D                          LOAD UART_data[sF], character_m[6D]
 1F2  30154                          CALL send_to_UART[154]
 1F3  00F65                          LOAD UART_data[sF], character_e[65]
 1F4  30154                          CALL send_to_UART[154]
 1F5  00F72                          LOAD UART_data[sF], character_r[72]
 1F6  30154                          CALL send_to_UART[154]
 1F7  301B9                          CALL send_space[1B9]
 1F8  00F76                          LOAD UART_data[sF], character_v[76]
 1F9  30154                          CALL send_to_UART[154]
 1FA  00F31                          LOAD UART_data[sF], character_1[31]
 1FB  30154                          CALL send_to_UART[154]
 1FC  00F2E                          LOAD UART_data[sF], character_fullstop[2E]
 1FD  30154                          CALL send_to_UART[154]
 1FE  00F30                          LOAD UART_data[sF], character_0[30]
 1FF  30154                          CALL send_to_UART[154]
 200  00F30                          LOAD UART_data[sF], character_0[30]
 201  30154                          CALL send_to_UART[154]
 202  301B6                          CALL send_CR[1B6]
 203  301B6                          CALL send_CR[1B6]
 204  2A000                          RETURN
 205                                 ;
 205                                 ;
 205                                 ;
 205                                 ;Send 'Waiting_MCS_file' string to the UART
 205                                 ;
 205  00F57   send_Waiting_MCS_file: LOAD UART_data[sF], character_W[57]
 206  30154                          CALL send_to_UART[154]
 207  00F61                          LOAD UART_data[sF], character_a[61]
 208  30154                          CALL send_to_UART[154]
 209  00F69                          LOAD UART_data[sF], character_i[69]
 20A  30154                          CALL send_to_UART[154]
 20B  00F74                          LOAD UART_data[sF], character_t[74]
 20C  30154                          CALL send_to_UART[154]
 20D  00F69                          LOAD UART_data[sF], character_i[69]
 20E  30154                          CALL send_to_UART[154]
 20F  00F6E                          LOAD UART_data[sF], character_n[6E]
 210  30154                          CALL send_to_UART[154]
 211  00F67                          LOAD UART_data[sF], character_g[67]
 212  30154                          CALL send_to_UART[154]
 213  301B9                          CALL send_space[1B9]
 214  00F66                          LOAD UART_data[sF], character_f[66]
 215  30154                          CALL send_to_UART[154]
 216  00F6F                          LOAD UART_data[sF], character_o[6F]
 217  30154                          CALL send_to_UART[154]
 218  00F72                          LOAD UART_data[sF], character_r[72]
 219  30154                          CALL send_to_UART[154]
 21A  301B9           send_MCS_file: CALL send_space[1B9]
 21B  00F4D                          LOAD UART_data[sF], character_M[4D]
 21C  30154                          CALL send_to_UART[154]
 21D  00F43                          LOAD UART_data[sF], character_C[43]
 21E  30154                          CALL send_to_UART[154]
 21F  00F53                          LOAD UART_data[sF], character_S[53]
 220  30154                          CALL send_to_UART[154]
 221  301B9                          CALL send_space[1B9]
 222  00F46                          LOAD UART_data[sF], character_F[46]
 223  30154                          CALL send_to_UART[154]
 224  00F69                          LOAD UART_data[sF], character_i[69]
 225  30154                          CALL send_to_UART[154]
 226  00F6C                          LOAD UART_data[sF], character_l[6C]
 227  30154                          CALL send_to_UART[154]
 228  00F65                          LOAD UART_data[sF], character_e[65]
 229  30154                          CALL send_to_UART[154]
 22A  301B6                          CALL send_CR[1B6]
 22B  2A000                          RETURN
 22C                                 ;
 22C                                 ;
 22C                                 ;Send 'Erase in progress' string to the UART
 22C                                 ;
 22C  30243  send_Erase_in_progress: CALL send_Erase[243]
 22D  00F69                          LOAD UART_data[sF], character_i[69]
 22E  30154                          CALL send_to_UART[154]
 22F  00F6E                          LOAD UART_data[sF], character_n[6E]
 230  30154                          CALL send_to_UART[154]
 231  301B9                          CALL send_space[1B9]
 232  00F50                          LOAD UART_data[sF], character_P[50]
 233  30154                          CALL send_to_UART[154]
 234  00F72                          LOAD UART_data[sF], character_r[72]
 235  30154                          CALL send_to_UART[154]
 236  00F6F                          LOAD UART_data[sF], character_o[6F]
 237  30154                          CALL send_to_UART[154]
 238  00F67                          LOAD UART_data[sF], character_g[67]
 239  30154                          CALL send_to_UART[154]
 23A  00F72                          LOAD UART_data[sF], character_r[72]
 23B  30154                          CALL send_to_UART[154]
 23C  00F65                          LOAD UART_data[sF], character_e[65]
 23D  30154                          CALL send_to_UART[154]
 23E  00F73                          LOAD UART_data[sF], character_s[73]
 23F  30154                          CALL send_to_UART[154]
 240  30154                          CALL send_to_UART[154]
 241  301B6                          CALL send_CR[1B6]
 242  2A000                          RETURN
 243                                 ;
 243                                 ;
 243                                 ;Send 'Erase ' string to the UART
 243                                 ;
 243  00F45              send_Erase: LOAD UART_data[sF], character_E[45]
 244  30154                          CALL send_to_UART[154]
 245  00F72                          LOAD UART_data[sF], character_r[72]
 246  30154                          CALL send_to_UART[154]
 247  00F61                          LOAD UART_data[sF], character_a[61]
 248  30154                          CALL send_to_UART[154]
 249  00F73                          LOAD UART_data[sF], character_s[73]
 24A  30154                          CALL send_to_UART[154]
 24B  00F65                          LOAD UART_data[sF], character_e[65]
 24C  30154                          CALL send_to_UART[154]
 24D  301B9                          CALL send_space[1B9]
 24E  2A000                          RETURN
 24F                                 ;
 24F                                 ;
 24F                                 ;Send carriage return, 'OK' and carriage return to the UART
 24F                                 ;
 24F  301B6                 send_OK: CALL send_CR[1B6]
 250  00F4F                          LOAD UART_data[sF], character_O[4F]
 251  30154                          CALL send_to_UART[154]
 252  00F4B                          LOAD UART_data[sF], character_K[4B]
 253  30154                          CALL send_to_UART[154]
 254  301B6                          CALL send_CR[1B6]
 255  2A000                          RETURN
 256                                 ;
 256                                 ;
 256                                 ;
 256                                 ;Send menu to the UART
 256                                 ;
 256  301B6               send_Menu: CALL send_CR[1B6]
 257  00F45                          LOAD UART_data[sF], character_E[45]
 258  30154                          CALL send_to_UART[154]
 259  00F2D                          LOAD UART_data[sF], character_minus[2D]
 25A  30154                          CALL send_to_UART[154]
 25B  30243                          CALL send_Erase[243]
 25C  00F61                          LOAD UART_data[sF], character_a[61]
 25D  30154                          CALL send_to_UART[154]
 25E  00F6C                          LOAD UART_data[sF], character_l[6C]
 25F  30154                          CALL send_to_UART[154]
 260  30154                          CALL send_to_UART[154]
 261  301B6                          CALL send_CR[1B6]
 262  00F42                          LOAD UART_data[sF], character_B[42]
 263  30154                          CALL send_to_UART[154]
 264  00F2D                          LOAD UART_data[sF], character_minus[2D]
 265  30154                          CALL send_to_UART[154]
 266  30243                          CALL send_Erase[243]
 267  00F62                          LOAD UART_data[sF], character_b[62]
 268  30154                          CALL send_to_UART[154]
 269  00F6C                          LOAD UART_data[sF], character_l[6C]
 26A  30154                          CALL send_to_UART[154]
 26B  00F6F                          LOAD UART_data[sF], character_o[6F]
 26C  30154                          CALL send_to_UART[154]
 26D  00F63                          LOAD UART_data[sF], character_c[63]
 26E  30154                          CALL send_to_UART[154]
 26F  00F6B                          LOAD UART_data[sF], character_k[6B]
 270  30154                          CALL send_to_UART[154]
 271  00F73                          LOAD UART_data[sF], character_s[73]
 272  30154                          CALL send_to_UART[154]
 273  301B9                          CALL send_space[1B9]
 274  00F31                          LOAD UART_data[sF], character_1[31]
 275  30154                          CALL send_to_UART[154]
 276  00F2D                          LOAD UART_data[sF], character_minus[2D]
 277  30154                          CALL send_to_UART[154]
 278  00F33                          LOAD UART_data[sF], character_3[33]
 279  30154                          CALL send_to_UART[154]
 27A  301B6                          CALL send_CR[1B6]
 27B  00F50                          LOAD UART_data[sF], character_P[50]
 27C  30154                          CALL send_to_UART[154]
 27D  00F2D                          LOAD UART_data[sF], character_minus[2D]
 27E  30154                          CALL send_to_UART[154]
 27F  00F50                          LOAD UART_data[sF], character_P[50]
 280  30154                          CALL send_to_UART[154]
 281  00F72                          LOAD UART_data[sF], character_r[72]
 282  30154                          CALL send_to_UART[154]
 283  00F6F                          LOAD UART_data[sF], character_o[6F]
 284  30154                          CALL send_to_UART[154]
 285  00F67                          LOAD UART_data[sF], character_g[67]
 286  30154                          CALL send_to_UART[154]
 287  00F72                          LOAD UART_data[sF], character_r[72]
 288  30154                          CALL send_to_UART[154]
 289  00F61                          LOAD UART_data[sF], character_a[61]
 28A  30154                          CALL send_to_UART[154]
 28B  00F6D                          LOAD UART_data[sF], character_m[6D]
 28C  30154                          CALL send_to_UART[154]
 28D  3021A                          CALL send_MCS_file[21A]
 28E  00F57                          LOAD UART_data[sF], character_W[57]
 28F  30154                          CALL send_to_UART[154]
 290  00F2D                          LOAD UART_data[sF], character_minus[2D]
 291  30154                          CALL send_to_UART[154]
 292  00F57                          LOAD UART_data[sF], character_W[57]
 293  30154                          CALL send_to_UART[154]
 294  00F72                          LOAD UART_data[sF], character_r[72]
 295  30154                          CALL send_to_UART[154]
 296  00F69                          LOAD UART_data[sF], character_i[69]
 297  30154                          CALL send_to_UART[154]
 298  00F74                          LOAD UART_data[sF], character_t[74]
 299  30154                          CALL send_to_UART[154]
 29A  00F65                          LOAD UART_data[sF], character_e[65]
 29B  30154                          CALL send_to_UART[154]
 29C  301B9                          CALL send_space[1B9]
 29D  302EE                          CALL send_byte[2EE]
 29E  301B6                          CALL send_CR[1B6]
 29F  00F52                          LOAD UART_data[sF], character_R[52]
 2A0  30154                          CALL send_to_UART[154]
 2A1  00F2D                          LOAD UART_data[sF], character_minus[2D]
 2A2  30154                          CALL send_to_UART[154]
 2A3  00F52                          LOAD UART_data[sF], character_R[52]
 2A4  30154                          CALL send_to_UART[154]
 2A5  00F65                          LOAD UART_data[sF], character_e[65]
 2A6  30154                          CALL send_to_UART[154]
 2A7  00F61                          LOAD UART_data[sF], character_a[61]
 2A8  30154                          CALL send_to_UART[154]
 2A9  00F64                          LOAD UART_data[sF], character_d[64]
 2AA  30154                          CALL send_to_UART[154]
 2AB  301B9                          CALL send_space[1B9]
 2AC  00F32                          LOAD UART_data[sF], character_2[32]
 2AD  30154                          CALL send_to_UART[154]
 2AE  00F35                          LOAD UART_data[sF], character_5[35]
 2AF  30154                          CALL send_to_UART[154]
 2B0  00F36                          LOAD UART_data[sF], character_6[36]
 2B1  30154                          CALL send_to_UART[154]
 2B2  301B9                          CALL send_space[1B9]
 2B3  302EE                          CALL send_byte[2EE]
 2B4  00F73                          LOAD UART_data[sF], character_s[73]
 2B5  30154                          CALL send_to_UART[154]
 2B6  301B6                          CALL send_CR[1B6]
 2B7  00F49                          LOAD UART_data[sF], character_I[49]
 2B8  30154                          CALL send_to_UART[154]
 2B9  00F2D                          LOAD UART_data[sF], character_minus[2D]
 2BA  30154                          CALL send_to_UART[154]
 2BB  00F44                          LOAD UART_data[sF], character_D[44]
 2BC  30154                          CALL send_to_UART[154]
 2BD  00F65                          LOAD UART_data[sF], character_e[65]
 2BE  30154                          CALL send_to_UART[154]
 2BF  00F76                          LOAD UART_data[sF], character_v[76]
 2C0  30154                          CALL send_to_UART[154]
 2C1  00F69                          LOAD UART_data[sF], character_i[69]
 2C2  30154                          CALL send_to_UART[154]
 2C3  00F63                          LOAD UART_data[sF], character_c[63]
 2C4  30154                          CALL send_to_UART[154]
 2C5  00F65                          LOAD UART_data[sF], character_e[65]
 2C6  30154                          CALL send_to_UART[154]
 2C7  301B9                          CALL send_space[1B9]
 2C8  302E9                          CALL send_ID[2E9]
 2C9  301B6                          CALL send_CR[1B6]
 2CA  00F48                          LOAD UART_data[sF], character_H[48]
 2CB  30154                          CALL send_to_UART[154]
 2CC  00F2D                          LOAD UART_data[sF], character_minus[2D]
 2CD  30154                          CALL send_to_UART[154]
 2CE  00F48                          LOAD UART_data[sF], character_H[48]
 2CF  30154                          CALL send_to_UART[154]
 2D0  00F65                          LOAD UART_data[sF], character_e[65]
 2D1  30154                          CALL send_to_UART[154]
 2D2  00F6C                          LOAD UART_data[sF], character_l[6C]
 2D3  30154                          CALL send_to_UART[154]
 2D4  00F70                          LOAD UART_data[sF], character_p[70]
 2D5  30154                          CALL send_to_UART[154]
 2D6  301B6                          CALL send_CR[1B6]
 2D7  00F53                          LOAD UART_data[sF], character_S[53]
 2D8  30154                          CALL send_to_UART[154]
 2D9  00F2D                          LOAD UART_data[sF], character_minus[2D]
 2DA  30154                          CALL send_to_UART[154]
 2DB  00F53                          LOAD UART_data[sF], character_S[53]
 2DC  30154                          CALL send_to_UART[154]
 2DD  00F74                          LOAD UART_data[sF], character_t[74]
 2DE  30154                          CALL send_to_UART[154]
 2DF  00F61                          LOAD UART_data[sF], character_a[61]
 2E0  30154                          CALL send_to_UART[154]
 2E1  00F74                          LOAD UART_data[sF], character_t[74]
 2E2  30154                          CALL send_to_UART[154]
 2E3  00F75                          LOAD UART_data[sF], character_u[75]
 2E4  30154                          CALL send_to_UART[154]
 2E5  00F73                          LOAD UART_data[sF], character_s[73]
 2E6  30154                          CALL send_to_UART[154]
 2E7  301B6                          CALL send_CR[1B6]
 2E8  2A000                          RETURN
 2E9                                 ;
 2E9                                 ;
 2E9                                 ;Send 'ID' to the UART
 2E9                                 ;
 2E9  00F49                 send_ID: LOAD UART_data[sF], character_I[49]
 2EA  30154                          CALL send_to_UART[154]
 2EB  00F44                          LOAD UART_data[sF], character_D[44]
 2EC  30154                          CALL send_to_UART[154]
 2ED  2A000                          RETURN
 2EE                                 ;
 2EE                                 ;
 2EE                                 ;Send 'byte' to the UART
 2EE                                 ;
 2EE  00F62               send_byte: LOAD UART_data[sF], character_b[62]
 2EF  30154                          CALL send_to_UART[154]
 2F0  00F79                          LOAD UART_data[sF], character_y[79]
 2F1  30154                          CALL send_to_UART[154]
 2F2  00F74                          LOAD UART_data[sF], character_t[74]
 2F3  30154                          CALL send_to_UART[154]
 2F4  00F65                          LOAD UART_data[sF], character_e[65]
 2F5  30154                          CALL send_to_UART[154]
 2F6  2A000                          RETURN
 2F7                                 ;
 2F7                                 ;
 2F7                                 ;Send 'Confirm Erase (Y/n) ' to the UART
 2F7                                 ;
 2F7  301B6            send_Confirm: CALL send_CR[1B6]
 2F8  00F43                          LOAD UART_data[sF], character_C[43]
 2F9  30154                          CALL send_to_UART[154]
 2FA  00F6F                          LOAD UART_data[sF], character_o[6F]
 2FB  30154                          CALL send_to_UART[154]
 2FC  00F6E                          LOAD UART_data[sF], character_n[6E]
 2FD  30154                          CALL send_to_UART[154]
 2FE  00F66                          LOAD UART_data[sF], character_f[66]
 2FF  30154                          CALL send_to_UART[154]
 300  00F69                          LOAD UART_data[sF], character_i[69]
 301  30154                          CALL send_to_UART[154]
 302  00F72                          LOAD UART_data[sF], character_r[72]
 303  30154                          CALL send_to_UART[154]
 304  00F6D                          LOAD UART_data[sF], character_m[6D]
 305  30154                          CALL send_to_UART[154]
 306  301B9                          CALL send_space[1B9]
 307  30243                          CALL send_Erase[243]
 308  00F28                          LOAD UART_data[sF], character_open[28]
 309  30154                          CALL send_to_UART[154]
 30A  00F59                          LOAD UART_data[sF], character_Y[59]
 30B  30154                          CALL send_to_UART[154]
 30C  00F2F                          LOAD UART_data[sF], character_divide[2F]
 30D  30154                          CALL send_to_UART[154]
 30E  00F6E                          LOAD UART_data[sF], character_n[6E]
 30F  30154                          CALL send_to_UART[154]
 310  00F29                          LOAD UART_data[sF], character_close[29]
 311  30154                          CALL send_to_UART[154]
 312  301B9                          CALL send_space[1B9]
 313  2A000                          RETURN
 314                                 ;
 314                                 ;
 314                                 ;Send 'Abort' to the UART
 314                                 ;
 314  301B6              send_Abort: CALL send_CR[1B6]
 315  00F41                          LOAD UART_data[sF], character_A[41]
 316  30154                          CALL send_to_UART[154]
 317  00F62                          LOAD UART_data[sF], character_b[62]
 318  30154                          CALL send_to_UART[154]
 319  00F6F                          LOAD UART_data[sF], character_o[6F]
 31A  30154                          CALL send_to_UART[154]
 31B  00F72                          LOAD UART_data[sF], character_r[72]
 31C  30154                          CALL send_to_UART[154]
 31D  00F74                          LOAD UART_data[sF], character_t[74]
 31E  30154                          CALL send_to_UART[154]
 31F  301B6                          CALL send_CR[1B6]
 320  2A000                          RETURN
 321                                 ;
 321                                 ;Send 'address=' to the UART
 321                                 ;
 321  301B6            send_address: CALL send_CR[1B6]
 322  00F61                          LOAD UART_data[sF], character_a[61]
 323  30154                          CALL send_to_UART[154]
 324  00F64                          LOAD UART_data[sF], character_d[64]
 325  30154                          CALL send_to_UART[154]
 326  30154                          CALL send_to_UART[154]
 327  00F72                          LOAD UART_data[sF], character_r[72]
 328  30154                          CALL send_to_UART[154]
 329  00F65                          LOAD UART_data[sF], character_e[65]
 32A  30154                          CALL send_to_UART[154]
 32B  00F73                          LOAD UART_data[sF], character_s[73]
 32C  30154                          CALL send_to_UART[154]
 32D  30154                          CALL send_to_UART[154]
 32E  00F3D             send_equals: LOAD UART_data[sF], character_equals[3D]
 32F  30154                          CALL send_to_UART[154]
 330  2A000                          RETURN
 331                                 ;
 331                                 ;
 331                                 ;Send 'data=' to the UART
 331                                 ;
 331  301B6               send_data: CALL send_CR[1B6]
 332  00F64                          LOAD UART_data[sF], character_d[64]
 333  30154                          CALL send_to_UART[154]
 334  00F61                          LOAD UART_data[sF], character_a[61]
 335  30154                          CALL send_to_UART[154]
 336  00F74                          LOAD UART_data[sF], character_t[74]
 337  30154                          CALL send_to_UART[154]
 338  00F61                          LOAD UART_data[sF], character_a[61]
 339  30154                          CALL send_to_UART[154]
 33A  3432E                          JUMP send_equals[32E]
 33B                                 ;
 33B                                 ;
 33B                                 ;**************************************************************************************
 33B                                 ;Interrupt Service Routine (ISR)
 33B                                 ;**************************************************************************************
 33B                                 ;
 33B                                 ;An interrupt occurs whenever the status of the UART receiver FIFO 'half_full' flag
 33B                                 ;changes.
 33B                                 ;
 33B                                 ;A change from Low to High means that the buffer is becoming full and therefore
 33B                                 ;an XOFF character must be transmitted.
 33B                                 ;
 33B                                 ;A change from High to Low means that the buffer is starting to empty and therefore
 33B                                 ;an XON character can be transmitted to restart the flow of new characters.
 33B                                 ;
 33B                                 ;
 3F5                                 ADDRESS 3F5                                    ;place at end of memory to keep separate
 3F5  2E000                     ISR: STORE s0, ISR_preserve_s0[00]                  ;preserve register contents
 3F6  04000                          INPUT s0, status_port[00]                      ;test 'half_full' status of receiver buffer.
 3F7  12010                          TEST s0, rx_half_full[10]
 3F8  353FB                          JUMP Z, isr_send_xon[3FB]
 3F9  00013                          LOAD s0, character_XOFF[13]
 3FA  343FC                          JUMP isr_send_character[3FC]
 3FB  00011            isr_send_xon: LOAD s0, character_XON[11]
 3FC  2C004      isr_send_character: OUTPUT s0, UART_write_port[04]
 3FD  06000                          FETCH s0, ISR_preserve_s0[00]                  ;restore register contents
 3FE  38001                          RETURNI ENABLE
 3FF                                 ;
 3FF                                 ;
 3FF                                 ;**************************************************************************************
 3FF                                 ;Interrupt Vector
 3FF                                 ;**************************************************************************************
 3FF                                 ;
 3FF                                 ADDRESS 3FF
 3FF  343F5                          JUMP ISR[3F5]
 3FF                                 ;
 3FF                                 ;
